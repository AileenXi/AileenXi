---
layout: post
title: 折腾一个Two_Sum（中）
---
<div class="message">
在这篇文章里，我仍旧聚焦Two Sum，开始尝试降低复杂度以及怎么在各种语言里写散列表。
</div>

#### Two Sum题干：

>Given an array of integers, return indices of the two numbers such that they
>add up to a specific target.
>You may assume that each input would have exactly one solution, and you may
>not use the same element twice. 
>Example:
>Given nums = [2, 7, 11, 15], target = 9,
>Because nums[0] + nums[1] = 2 + 7 = 9,
>return [0, 1].

上次我的最天（bai）真（chi）解法吗，所有都通过了，除了Python3运行超时了。我没有放弃，如果简单写两层For循环注定超时的话，那我还有一个选项，就是用它的迭代器模块，itertools。如果模块内部有优化的话，我可能可以侥幸以最天真思维通过它。


#### Python3.x解一之itertools：

{% highlight python %}
class Solution:
    import itertools
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        comb = itertools.combinations(nums,2)
        res = [x for x in comb if sum(y for y in x) == target]
        i = nums.index(res[0][0])
        j = nums.index(res[0][1],i+1)
        return [i,j]      
{% endhighlight %}

如果输入nums=[3,3]，target=6，我原来程序会返回[0,0]，但正确的结果是[0,1]，因为nums.index[3]返回0，后来发现index的第二个参数，开始搜索的下标，所以把它设成上一个结果的下标+1就可以得到第二个3的期待下标了。

Performance: `Time Out`

还是超时了，嗯，至少知道了python里的itertools并没有什么优化。
现在就正式进行优化了，用<strong>散列表</strong>，花费空间来优化时间，可以把时间复杂度从O(n<sup>2</sup>)降低到O(n),散列表要存储n个数组，空间复杂度从O(1)上升到O(n)。

#### C++解二：
{% highlight cpp %}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int,int> hash_table;
	//two-pass
        for (int i=0; i<nums.size(); i++){
            hash_table[nums[i]] = i;
        }
        for (int i =0; i<nums.size()-1; i++){
            int location = hash_table.find(target-nums[i])->second;
            if(location !=i && location != hash_table.end()->second){
                result.push_back(i);
                result.push_back(location);
                return result;
            }
        }
        throw std::invalid_argument("No solution"); 
    }
};
{% endhighlight %}
Performance: `19ms`

上面的代码思路很简单，先构建数据结构后求解。用一个`for`循环来构建一个散列表。然后再用一次`for`来搜索求解。算上常数，时间复杂度是线性时间——`2n`。

算法问题上往往有“抖机灵”做法，透彻了解问题后然后想出解题思路，过程就是——想。

这道题里还可以“抖机灵”，并不需要完整的散列表，可以一边构建一边搜索，这样时间可以从`2n`下降到`n`，在设计算法时，时间复杂度往往是忽略掉常数项的，但在实战里，去掉一个`for`可以把运行时间减半。下面的代码就把运行时间从`19ms`减少到`10ms`。


#### C++解三：
{% highlight cpp %}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int,int> hash_table;
	//one-pass
        for (int i=0; i<nums.size(); i++){
                int location = hash_table.find(target-nums[i])->second;
                if(location != hash_table.end()->second){
                result.push_back(location-1);
                result.push_back(i);
                return result;}  
                else{
                hash_table[nums[i]] = i+1;
                }
        }
        
        throw std::invalid_argument("No solution"); 
    }
        
};
{% endhighlight %}
Performance: 10ms

![placeholder](/image/2018-01-19-Cpp.png "C++ Performance with 3 Algorithms")


#### 各语言的散列表实现：

下面是其他语言的解三实现。

#### 背景音乐和预告：

- 音乐Björk的 [Utopia](https://open.spotify.com/album/2XeQDERy5XDj5O2ImrR61Q) ，她应该是我见过的最优创造力和艺术感，甚至不仅仅是音乐的艺术家。
- 下次还是这一题，我们研究一下不同的排序算法。 

如果有建议，观点或者问题的话，可以给我发邮件`aileen365@gmail.com`。


