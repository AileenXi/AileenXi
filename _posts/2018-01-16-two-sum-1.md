---
layout: post
title: 折腾一个Two_Sum（中）
---
<div class="message">
在这篇文章里，我仍旧聚焦Two Sum，开始尝试降低复杂度以及怎么在各种语言里写散列表。
</div>

#### Two Sum题干和又一次失败：

>Given an array of integers, return indices of the two numbers such that they
>add up to a specific target.
>You may assume that each input would have exactly one solution, and you may
>not use the same element twice. 
>Example:
>Given nums = [2, 7, 11, 15], target = 9,
>Because nums[0] + nums[1] = 2 + 7 = 9,
>return [0, 1].

上次我的最天（bai）真（chi）解法，所有都通过了，除了`Python3`运行超时。没放弃，如果简单写两层`for`循环注定超时，那还有一个尝试项——用它的迭代器模块`itertools`。如果模块内部有优化的话，可能可以以<strong>语言的优秀特性</strong>来弥补思维上的<strong>不聪明</strong>。


#### Python3.x解一之itertools：

{% highlight python %}
class Solution:
    import itertools
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        comb = itertools.combinations(nums,2)
        res = [x for x in comb if sum(y for y in x) == target]
        i = nums.index(res[0][0])
        j = nums.index(res[0][1],i+1)
        return [i,j]      
{% endhighlight %}

如果输入`nums=[3,3]`，`target=6`，原来程序会返回`[0,0]`，但正确的结果是`[0,1]`，因为`nums.index[3]`返回`0`，后来发现`index`的第二个参数——`开始搜索的下标`，所以把它设成`上一个结果的下标+1`就可以得到第二个`3`的`期待下标`了。

Performance: `Time Out`

还是超时了，嗯，至少知道了`python`里的`itertools`并<strong>没有</strong>优化。
现在就正式从数据结构上进行优化了，这到底是个什么问题，是搜索问题啊，天真算法里我们用了“挨个搜索”算法（如果使劲要一个名称的话）。好，现在想想我们有什么要什么，无序数列，搜索，数值-下标，<strong>散列表</strong>浮现眼前，花费空间来优化时间，可以把时间复杂度从O(n<sup>2</sup>)降低到O(n),散列表要存n个数值-下标对，空间复杂度从O(1)上升到O(n)。

#### C++解二——数据结构优化——2-Pass Hash Table：
{% highlight cpp %}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int,int> hash_table;
	//two-pass
        for (int i=0; i<nums.size(); i++){
            hash_table[nums[i]] = i;
        }
        for (int i =0; i<nums.size()-1; i++){
            int location = hash_table.find(target-nums[i])->second;
            if(location !=i && location != hash_table.end()->second){
                result.push_back(i);
                result.push_back(location);
                return result;
            }
        }
        throw std::invalid_argument("No solution"); 
    }
};
{% endhighlight %}
Performance: `19ms`

上面的代码思路很简单，先构建数据结构后求解。用一个`for`循环来构建一个散列表。然后再用一次`for`来搜索求解。算上常数，时间复杂度是线性时间——`2n`。

算法问题上往往有“抖机灵”做法，透彻了解问题后然后想出解题思路，过程就是——想。

这道题里还可以“抖机灵”（严肃点说是“想算法“），我们需要完整的散列表吗？并没有，可以一边构建一边搜索，这样时间可以从`2n`下降到`n`，在设计算法时，时间复杂度往往是忽略掉常数项的，但在实战里，去掉一个`for`可以把运行时间减半。下面的代码就把运行时间从`19ms`减少到`10ms`。而空间上散列表的任务也从存储固定n对下降到最多n-1对。这进一步的优化，不是靠数据结构，是靠——<strong>想</strong>（“算法”，“方法”，“抖出来的机灵”等等）


#### C++解三——进一步算法优化——1-Pass Hash Table：
{% highlight cpp %}
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int,int> hash_table;
	//one-pass
        for (int i=0; i<nums.size(); i++){
                int location = hash_table.find(target-nums[i])->second;
                if(location != hash_table.end()->second){
                result.push_back(location-1);
                result.push_back(i);
                return result;}  
                else{
                hash_table[nums[i]] = i+1;
                }
        }
        
        throw std::invalid_argument("No solution"); 
    }
        
};
{% endhighlight %}
Performance: 10ms

![placeholder](/image/2018-01-19-Cpp.png "C++ Performance with 3 Algorithms")


#### 各语言的散列表实现：

下面是其他语言的解三实现。

#### 背景音乐和预告：

- 音乐Björk的 [Utopia](https://open.spotify.com/album/2XeQDERy5XDj5O2ImrR61Q) ，她的作品刷新了我的感官。
- 下次还是这一题，我想研究一下不同的排序算法。 

如果有建议，观点或者问题的话，可以给我发邮件`aileen365@gmail.com`。


